# 도커 정리

## 도커의 정의

- 컨테이너 : 종속성 및 필요한 모든 구성을 포함하여 패키지 내부에 모든 것을 포함하여 애플리케이션을 패키징 하는 것

- 다른 아티팩트처럼 이식가능, 즉 다른 팀 간에 쉽게 패키지를 공유하고 이동할 수 있음

- 배포 프로세스를 좀 더 효율적으로 만들어줌(격리된 장소에 배포된 것은)

- 컨테이너는 기본적으로 공유하고 이동할 수 있도록 컨테이너 저장소에 남음, 일종의 스토리지가 존재(회사는 private 스토리지)

- 도커 컨테이너용 공용 리포지터리 - 도커허브 : 별도의 인증이 따로 필요없음

- 컨테이너 전에 개발을 어떻게 했는가 - 대부분의 서비스를 운영체제에 직접 깔아야 함. 모든 개발자가 서비스의 바어니리 파일을 깔아야 하므로 먼저 환경을 구성해야 됨. node일시 의존하는 모듈을 모두 설치해야만 함. 운영체제에 따라 이 절차가 다를 수밖에 없고, 애플리케이션 환경 조성에 많은 단계를 거쳐야 하기 때문에 잘못될 확률이 높음

- 컨테이너 - 리눅스 기반 이미지가 있는 자체 격리된 운영 체제 계층환므로, 운영 체제에 직접 서비스를 설치하지 않아도 됨. 하나의 컨테이너 내부에 있는 시작 스크립트의 구성과 함께 패키지된 특정 버전의 node가 있음. 특정 컨테이너 리포지터리를 찾아서 단순히 다운로드하면 됨, 즉 단계 자체가 많이 적어짐, 다운로드 또한 한 개의 도커 명령/ 따라서 같은 애플리케이션이나 다른 버전을 실제로 가질 수 있음

## 배포 프로세스 차이

- 컨테이너 도입 이전 - 개발 팀은 아티팩트를 서버에 실제로 설치하고 구성하는 방법에 대한 일련의 지침과 함께 아티팩트를 생성, 응용 프로그램에 관한 빌드 파일이 있음. 운영 팀은 이를 배포하기 위한 환경 설정을 처리(운영 체제에 직접 설치 = 종속성 및 실행 중인 여러 서비스와 충돌이 일어날 수 있음/ 개발 팀과 운영 팀 간의 오해가 생길 수밖에 없음)

- 이후 - 개발자와 운영자가 한 팀에서 작업 가능하며, 종속성을 애플리케이션 내부에 패키징하므로 프로세스는 실제로 단순화됨(캢슐화가 되어 있음). 리포지터리에서 컨테이너 이미지를 도커 명령어로 실행하기만 하면 됨. 별도의 서버 구성이 필요 없음

## 기술적인 컨테이너

- 간단하게 **이미지** - 이미지 레이어

  - node:16 Layer - 어플리케이션 이미지, 단순화된 다이어그램(맨 윗 층 = 어플리케이션 계층)
  - Layer1 - 계층 분할
  - Layer2 - 계층 분할
  - alpine:3.10 Layer - 리눅스 기반 이미지로 컨테이너 크기를 작게 유지할 수 있는 기본 이미지

- 다음 버전을 다운받을 경우 일부 레이어가 존재하므로, 일부 레이어 이외에 다른 레이어만 설치

- 도커 이미지와 도커 컨테이너

  - 도커 이미지 - 실제 패키지, 구성 및 종속성과 같은 모든 것과 함께 실제로 이동할 수 있는 아티팩트(상품) - 실행 중이 아니라면 기본적으로 이미지

  - 도커 컨테이너 - 로컬 컴퓨터에서 해당 이미지를 가져오고 실제로 시작하여 내부 컨테이너 환경을 생성하는 내부 애플리케이션이 실제로 시작되는 때(상품을 담는 박스) - 실행 중이면 컨테이너(이미지의 실행 환경, 가상 파일 시스템)

  - port bind - 바인딩된 포트가 있어 내부에서 실행 중인 애플리케이션에 접근 가능. port 부분이 컨테이너가 들어오는 요청을 수신하는 포트

## 도커 vs virtual machine - 둘다 가상화 도구이나 왜 다른가?

- 운영 체제는 두 계층, 애플리케이션 계층과 기본적으로 커널 계층으로 나눠짐

- 커널은 하드웨어와 통신하는 계층

- 가상화하는 운영체제의 부분은 무엇? => 도커는 애플리케이션 계층을 가상화, VM은 응용 애플리케이션 계층과 자체적인 커널 계층

- 차이
  - 도커이미지는 한 레이어만 구현하므로 VM에 비해 훨씬 작음
  - 도커 컨테이너는 작동에 필요한 시간이 훨씬 적음
  - VM은 다른 운영 체제 호스트에서 모든 운영 체제의 가상 머신 이미지를 실행할 수 있지만, Docker는 불가(커널 계층이 따로 가상화 안되니까 커널과 응용계층이 호환 안 될 수 있음= 커널을 추상화하는 docker toolbox를 사용하면 가능함)

## 컨테이너 포트 vs 호스트 포트

- 서버(노트북)에는 특정 응용 프로그램을 위해 열 수 있는 특정 포트 존재(호스트 시스템이 가지고 있는 포트)

- 도커 컨테이너에는 바인딩된 포트가 있어 내부에서 실행 중인 애플리케이션에 접근 가능(컨테이너 포트)

- 호스트의 포트롤 실행중인 컨테이너 포트에 바인딩 가능

- `docker run -p 6000:6379 redis(호스트 포트 6000, 컨테이터 포트 6379)`

- 같은 호스트 포트로 지정할 경우, 이미 호스트 포트가 할당되어 있으므로 오류

- `docker run -p 6001:6379 redis(호스트 포트 6001, 컨테이터 포트 6379)` 이 명령어는 가능

- `docker run -d redis`는 분리모드에서 컨테이너 실행

- `docker exec -it [컨테이너id or 컨테이너 name] /bin/bash` - 실제로 실행 중인 컨테이너의 터미널 확인

## 도커네트워크

- `docker network create [network-name]` 도커 네트워크 생성

- `docker run -d -p 27017:27017 --name mongodb --net(network) [network 이름] mongo` 여기에다가 mongo에 관련된 도커허브로 사용자 이름과 패스워드를 덮어씌우기

- `bridge` 하나의 호스트 컴퓨터 내에서 여러 컨테이너들이 서로 소통.

- `host` 컨테이너를 호스트 컴퓨터와 동일한 네트워크에서 컨테이너를 운영하기 위해 사용.

- `overlay` 여러 호스트에 분산되어 돌아가는 컨테이너들 간에 네트워킹을 위해서 사용.

- `--net` 설정을 안할 시에는 디폴트 네트워크인 `bridge`에 소속됨

- ```bash
  docker run -d \
  -p 8081:8081 \
  -e ME_CONFIG_MONGODB_ADMINUSERNAME=admin \
  -e ME_CONFIG_MONGODB_ADMINPASSWORD=password \
  --net [network 이름]
  / 몽고 익스프레스 설치
  ```

## docker compose

- 도커 컴포즈에서는 실행될 네트워크를 따로 지정할 필요가 없음

- network는 디폴트로 'myapp_default'로 생성됨

- 하나의 컨테이너가 하나의 애플리케이션을 담당한다고 하면 여러 개의 컨테이너가 필요.

- 도커 컴포즈는 yaml 포맷으로 작성되며 여러 개의 컨테이너의 실행을 한 번에 관리를 할 수 있게 해 줌.

- 실행 `docker-compose -f [docker-compose 파일] -d up`

```yaml
  verison: '3
  services:
    mongodb(컨테이너 이름):
      image:mongo(도커 image)
      ports:
        - 27017:27017
      environments:
        - MONGO-INITDB_ROOT_USERNAME = admin
        - MONGO-INITDB_ROOT_PASSWORD = password
    mongo-express:
      image:mongo-express
      ports:
        - 8080:8081
      environment:
         - ME_CONFIG_MONGODB_ADMINUSERNAME=admin \
         - ME_CONFIG_MONGODB_ADMINPASSWORD=password \
```

```Docker
//dockrfile
FROM node
ENV MONGO-INITDB_ROOT_USERNAME = admin
    MONGO-INITDB_ROOT_PASSWORD = password
RUN mkdir -p /home/app
COPY ./home/app(실제로 호스트에서 실행되는 것 - 컨테이너 이미지 내부의 폴더를 호스트에 복사하는 것)
CMD ["node" , "server.js"] // entrypoint command - 모든 이미지는 다른 기본 이미지를 가지고 있음, 이경우
app: 1.0
node:13
alpine:3.10

```

- `docker build -t my-app:1.0(도커 이미지 이름) .(도커파일의 위치)`
